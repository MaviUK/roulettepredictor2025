<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Adaptive Directional Roulette Predictor (AR3) + Excel Days Upload</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
*{box-sizing:border-box}
body{margin:0;padding:1rem;background:#0b1020;color:#f5f5f5;font-family:system-ui}
h1,h2,h3{margin:.35rem 0}
.grid{display:grid;grid-template-columns:1.2fr 1fr;gap:1rem}
@media(max-width:900px){.grid{grid-template-columns:1fr}}
.card{background:#151a2c;border-radius:14px;padding:1rem;border:1px solid rgba(255,255,255,.08)}
label{display:block;font-size:.85rem;opacity:.85;margin:.4rem 0 .2rem}
input,select,textarea{width:100%;padding:.55rem;border-radius:10px;border:1px solid rgba(255,255,255,.15);background:#0b1020;color:#fff}
textarea{min-height:110px;resize:vertical}
.row{display:flex;gap:.6rem;flex-wrap:wrap}
.row>*{flex:1;min-width:180px}
button{border:0;border-radius:999px;padding:.5rem .9rem;font-weight:800;cursor:pointer}
.btn{background:#ff3366;color:#fff}
.btn2{background:#27325a;color:#fff}
button:disabled{opacity:.5;cursor:not-allowed}
.small{font-size:.82rem;opacity:.82;line-height:1.35}
.mono{font-family:ui-monospace,Menlo,Consolas,monospace}

.wheelWrap{display:flex;gap:1rem;flex-wrap:wrap;align-items:flex-start;margin-top:.8rem}
.wheel{width:360px;height:360px;border-radius:50%;position:relative;
background:radial-gradient(circle,rgba(255,255,255,.06),rgba(0,0,0,.35));
border:1px solid rgba(255,255,255,.1)}
@media(max-width:480px){.wheel{width:320px;height:320px}}
.pocket{position:absolute;left:50%;top:50%;transform-origin:0 0;pointer-events:none}
.chip{width:32px;height:22px;border-radius:8px;display:flex;align-items:center;justify-content:center;
font-weight:900;font-size:12px;color:#fff;border:1px solid rgba(255,255,255,.15);
transform:translate(-50%,-50%);box-shadow:0 6px 14px rgba(0,0,0,.25)}
.red{background:#c5283d}
.black{background:#111827}
.green{background:#0b7a3a}
.covered{outline:2px solid rgba(90,212,255,.95);outline-offset:2px}
.pred{outline:3px solid rgba(255,51,102,1);outline-offset:2px}

.nextBox{min-width:240px;flex:1;background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.08);
border-radius:12px;padding:.8rem}
.next{font-size:2.2rem;font-weight:950;line-height:1}
.pill{display:inline-flex;align-items:center;padding:.2rem .55rem;border-radius:999px;font-size:.72rem;font-weight:900;margin-right:.35rem}
.neutral{background:rgba(130,150,255,.15);color:#b3bfff}
.good{background:rgba(0,200,140,.15);color:#4cf3b6}
.bad{background:rgba(255,120,80,.15);color:#ffb899}

table{width:100%;border-collapse:collapse;margin-top:.5rem}
th,td{border-bottom:1px solid rgba(255,255,255,.08);padding:.35rem .35rem;text-align:left;font-size:.85rem;vertical-align:top}
th{opacity:.9}
.actions{display:flex;gap:.4rem;flex-wrap:wrap}
</style>
</head>

<body>

<h1>Adaptive Directional Roulette Predictor (AR3)</h1>
<p class="small">
Upload <b>.xlsx</b> where row 1 = day names (across columns) and spins are listed underneath each day column.
</p>

<div class="grid">

  <!-- LEFT: LIVE -->
  <div class="card">
    <h2>Live Mode</h2>

    <div class="row">
      <div>
        <label>Add spin (0–36)</label>
        <input id="spinInput" type="number" min="0" max="36" placeholder="Press Enter">
        <div class="small">Tip: press <b>Enter</b> to add quickly.</div>
      </div>
      <div style="flex:0;min-width:340px">
        <label>&nbsp;</label>
        <button class="btn" id="addBtn" type="button">Add</button>
        <button class="btn2" type="button" onclick="resetLive()">Reset</button>
        <button class="btn2" type="button" onclick="exportTxt()">Export .txt</button>
      </div>
    </div>

    <label>Paste spins (bulk) → Load into Live</label>
    <textarea id="bulkBox" placeholder="Example: 26 34 16 4 10 10 27 ..."></textarea>
    <div style="margin-top:.35rem" class="actions">
      <button class="btn2" type="button" onclick="loadBulkToLive()">Load Bulk → Live</button>
      <button class="btn2" type="button" onclick="appendBulkToLive()">Append Bulk</button>
    </div>

    <div id="status" class="small" style="margin-top:.6rem"></div>

    <div class="wheelWrap">
      <div class="wheel" id="wheel"></div>
      <div class="nextBox">
        <div class="small"><span class="pill neutral">NEXT</span> Predicted centre</div>
        <div class="next" id="nextCentre">–</div>
        <div class="small mono" id="nextMeta">No prediction yet.</div>
        <div class="small" style="margin-top:.65rem"><span class="pill neutral">LIVE COUNT</span></div>
        <div class="small mono" id="liveCount">0 spins</div>
      </div>
    </div>
  </div>

  <!-- RIGHT: SETTINGS + EXCEL DAYS -->
  <div class="card">
    <h2>Settings</h2>

    <div class="row">
      <div>
        <label>Neighbour half-sector</label>
        <input id="half" type="number" value="8" min="1" max="18">
        <div class="small">8 = cover 17 numbers</div>
      </div>
      <div>
        <label>Directional window N</label>
        <input id="windowN" type="number" value="6" min="5" max="25">
        <div class="small">Needs at least N directional distances in upcoming direction.</div>
      </div>
    </div>

    <label>Shift search range</label>
    <select id="shiftRange">
      <option value="0,1,2,3,4,5" selected>0–5</option>
      <option value="0,1,2,3,4,5,6,7,8,9,10">0–10</option>
    </select>

    <hr style="border:0;border-top:1px solid rgba(255,255,255,.08);margin:1rem 0">

    <h2>Excel / CSV Days Upload</h2>
    <p class="small">
      Upload your spreadsheet exactly as you described:
      <br>• Row 1: Day names across columns (e.g. Day 1, Day 2...)
      <br>• Rows below: spins 0–36 in each column
    </p>

    <input id="daysFile" type="file" accept=".xlsx,.xls,.csv" />

    <div class="actions" style="margin-top:.5rem">
      <button class="btn" type="button" onclick="loadDaysFile()">Load Days</button>
      <button class="btn2" type="button" onclick="clearDays()">Clear</button>
    </div>

    <div id="daysStatus" class="small" style="margin-top:.6rem"></div>

    <div id="daysResults" style="display:none;margin-top:.8rem">
      <h3>Day-by-Day Results (Historic Replay)</h3>
      <table class="mono">
        <thead>
          <tr>
            <th>Day</th>
            <th>Spins</th>
            <th>Bets</th>
            <th>Hit%</th>
            <th>Worst Losing Streak</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody id="daysTbody"></tbody>
        <tfoot>
          <tr>
            <td><b>TOTAL</b></td>
            <td id="totSpins"></td>
            <td id="totBets"></td>
            <td id="totHit"></td>
            <td id="totWorst"></td>
            <td></td>
          </tr>
        </tfoot>
      </table>
    </div>

  </div>

</div>

<!-- SheetJS for XLSX parsing -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<script>
/* =========================
   WHEEL + COLOURS
========================= */
const WHEEL=[0,32,15,19,4,21,2,25,17,34,6,27,13,36,11,30,8,23,10,5,24,16,33,1,20,14,31,9,22,18,29,7,28,12,35,3,26];
const IDX={}; WHEEL.forEach((n,i)=>IDX[n]=i);
const RED=new Set([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]);
function colourOf(n){ return n===0 ? "green" : (RED.has(n) ? "red" : "black"); }

const wheelEl=document.getElementById("wheel");
const pocketMap=new Map();
function buildWheel(){
  wheelEl.innerHTML="";
  pocketMap.clear();
  const rect = wheelEl.getBoundingClientRect();
  const size = Math.min(rect.width, rect.height);
  const r = size * 0.46;

  for(let i=0;i<WHEEL.length;i++){
    const n=WHEEL[i];
    const ang = -Math.PI/2 + (i/WHEEL.length)*2*Math.PI;
    const x = (size/2) + Math.cos(ang)*r;
    const y = (size/2) + Math.sin(ang)*r;

    const p=document.createElement("div");
    p.className="pocket";
    p.style.left = x+"px";
    p.style.top  = y+"px";

    const c=document.createElement("div");
    c.className=`chip ${colourOf(n)}`;
    c.textContent=n;

    p.appendChild(c);
    wheelEl.appendChild(p);
    pocketMap.set(n,c);
  }
}
function clearWheel(){
  pocketMap.forEach(ch=>ch.classList.remove("covered","pred"));
}
function highlightWheel(centre, covered){
  clearWheel();
  if(Array.isArray(covered)){
    covered.forEach(n=>pocketMap.get(n)?.classList.add("covered"));
  }
  if(typeof centre==="number"){
    pocketMap.get(centre)?.classList.add("pred");
  }
}
window.addEventListener("load", buildWheel);
window.addEventListener("resize", ()=>{
  buildWheel();
  if(lastPrediction && typeof lastPrediction.centre==="number"){
    highlightWheel(lastPrediction.centre, lastPrediction.covered);
  }
});

/* =========================
   CORE HELPERS
========================= */
const spinInput = document.getElementById("spinInput");
const addBtn = document.getElementById("addBtn");
const statusEl = document.getElementById("status");
const nextCentreEl = document.getElementById("nextCentre");
const nextMetaEl = document.getElementById("nextMeta");
const liveCountEl = document.getElementById("liveCount");

addBtn.addEventListener("click", ()=>addSpin());
spinInput.addEventListener("keydown", (e)=>{
  if(e.key==="Enter"){
    e.preventDefault();
    addSpin();
  }
});

function parseShiftOptions(){
  return document.getElementById("shiftRange").value.split(",")
    .map(x=>parseInt(x,10))
    .filter(Number.isFinite);
}

function dirForSpinIndex(i){ // i is index of the CURRENT spin (0-based)
  return i%2===0 ? "CW" : "CCW";
}
function dirForDistanceIndex(i){ // distance from spin i-1 -> i uses direction of spin i
  return i%2===0 ? "CW" : "CCW";
}

function neighbours(centre, half){
  const idx=IDX[centre];
  if(idx==null) return [];
  const out=[];
  for(let o=-half;o<=half;o++){
    out.push(WHEEL[(idx+o+37)%37]);
  }
  return out;
}

function buildDistances(history){
  const out=[];
  for(let i=1;i<history.length;i++){
    const a=IDX[history[i-1]], b=IDX[history[i]];
    if(a==null||b==null) continue;
    const d = (dirForDistanceIndex(i)==="CW") ? (b-a+37)%37 : (a-b+37)%37;
    out.push({dir:dirForDistanceIndex(i), dist:d, spinIndex:i});
  }
  return out;
}

/* =========================
   AR(3) FIT
   y = a + b1*x1 + b2*x2 + b3*x3
========================= */
function fitAR3(vals){
  if(vals.length < 6) return null;

  const A = [
    [0,0,0,0],
    [0,0,0,0],
    [0,0,0,0],
    [0,0,0,0]
  ];
  const B = [0,0,0,0];

  for(let i=3;i<vals.length;i++){
    const y = vals[i];
    const v = [1, vals[i-1], vals[i-2], vals[i-3]];
    for(let r=0;r<4;r++){
      B[r]+= v[r]*y;
      for(let c=0;c<4;c++){
        A[r][c]+= v[r]*v[c];
      }
    }
  }

  for(let i=0;i<4;i++) A[i][i]+=1e-4;

  for(let i=0;i<4;i++){
    let p=i;
    for(let r=i+1;r<4;r++){
      if(Math.abs(A[r][i]) > Math.abs(A[p][i])) p=r;
    }
    [A[i],A[p]]=[A[p],A[i]];
    [B[i],B[p]]=[B[p],B[i]];

    const div=A[i][i];
    if(Math.abs(div) < 1e-12) return null;

    for(let c=i;c<4;c++) A[i][c]/=div;
    B[i]/=div;

    for(let r=0;r<4;r++){
      if(r===i) continue;
      const f=A[r][i];
      for(let c=i;c<4;c++) A[r][c]-=f*A[i][c];
      B[r]-=f*B[i];
    }
  }

  return {a:B[0], b1:B[1], b2:B[2], b3:B[3]};
}

/* =========================
   PARAM SELECTION (adaptive)
========================= */
function chooseParamsForNext(history){
  const N = +document.getElementById("windowN").value;
  const shiftOptions = parseShiftOptions();

  const dists = buildDistances(history);
  const upcomingDir = dirForSpinIndex(history.length);
  const usable = dists.filter(x=>x.dir===upcomingDir);

  if(usable.length < N) return null;

  const fitVals = usable.slice(-N).map(x=>x.dist);
  const model = fitAR3(fitVals);
  if(!model) return null;

  const evalCount = Math.max(5, Math.min(N-1, 10));
  const evalRecs = usable.slice(-evalCount);

  let best=null;
  for(const shift of shiftOptions){
    let bets=0,hits=0;
    for(const rec of evalRecs){
      const s = rec.spinIndex;
      if(s+1 >= history.length) continue;
      const h = history.slice(0, s+1);
      const pred = predictCentreFromModel(h, model, shift);
      if(pred==null) continue;

      const half = +document.getElementById("half").value;
      const covered = neighbours(pred, half);
      const result = history[s+1];

      bets++;
      if(covered.includes(result)) hits++;
    }
    if(bets===0) continue;
    const hitRate = hits/bets;
    if(!best || hitRate > best.hitRate){
      best = {shift, model, hitRate, bets};
    }
  }
  return best;
}

function predictCentreFromModel(history, model, shift){
  const dists = buildDistances(history);
  const upcomingDir = dirForSpinIndex(history.length);
  const usable = dists.filter(x=>x.dir===upcomingDir).map(x=>x.dist);
  if(usable.length < 3) return null;

  const x1 = usable[usable.length-1];
  const x2 = usable[usable.length-2];
  const x3 = usable[usable.length-3];

  let step = Math.round(model.a + model.b1*x1 + model.b2*x2 + model.b3*x3);
  step = (step + shift) % 37;
  step = (step + 37) % 37;

  const lastIdx = IDX[history[history.length-1]];
  if(lastIdx==null) return null;

  const centreIdx = (upcomingDir==="CW")
    ? (lastIdx + step) % 37
    : (lastIdx - step + 74) % 37;

  return WHEEL[centreIdx];
}

/* =========================
   LIVE
========================= */
let spins = [];
let lastPrediction = null;

function addSpin(){
  const v = parseInt(spinInput.value,10);
  if(!Number.isFinite(v) || v<0 || v>36) return;
  spinInput.value="";
  spins.push(v);
  refreshLive();
  spinInput.focus();
}

function refreshLive(){
  liveCountEl.textContent = `${spins.length} spins`;

  nextCentreEl.textContent = "–";
  nextMetaEl.textContent = "No prediction yet.";
  clearWheel();

  if(spins.length < 2){
    statusEl.innerHTML = `<span class="pill neutral">WAIT</span> Add more spins.`;
    return;
  }

  const chosen = chooseParamsForNext(spins);
  if(!chosen){
    const dists = buildDistances(spins);
    const upcomingDir = dirForSpinIndex(spins.length);
    const have = dists.filter(x=>x.dir===upcomingDir).length;
    const need = +document.getElementById("windowN").value;
    statusEl.innerHTML = `<span class="pill neutral">WAIT</span> Need ${need} ${upcomingDir} distances (have ${have}).`;
    return;
  }

  const centre = predictCentreFromModel(spins, chosen.model, chosen.shift);
  if(centre==null){
    statusEl.innerHTML = `<span class="pill neutral">WAIT</span> Not enough structure yet to predict.`;
    return;
  }

  const half = +document.getElementById("half").value;
  const covered = neighbours(centre, half);

  lastPrediction = {centre, covered, chosen};

  nextCentreEl.textContent = String(centre);
  nextMetaEl.textContent = `shift=${chosen.shift} • evalHit=${(chosen.hitRate*100).toFixed(1)}% (n=${chosen.bets})`;
  highlightWheel(centre, covered);

  statusEl.innerHTML = `<span class="pill good">BET</span> Cover ${covered.length} numbers.`;
}

function resetLive(){
  spins = [];
  lastPrediction = null;
  refreshLive();
  spinInput.focus();
}

function exportTxt(){
  if(!spins.length){ alert("No spins to export."); return; }
  const blob = new Blob([spins.join("\n")], {type:"text/plain"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href=url;
  a.download="roulette_spins_live.txt";
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{document.body.removeChild(a);URL.revokeObjectURL(url);},0);
}

function parseSpinsText(text){
  const toks = text.split(/[\s,;]+/).filter(Boolean);
  const out=[];
  for(const t of toks){
    const v = parseInt(t,10);
    if(Number.isFinite(v) && v>=0 && v<=36) out.push(v);
  }
  return out;
}
function loadBulkToLive(){
  const txt = document.getElementById("bulkBox").value;
  const arr = parseSpinsText(txt);
  if(arr.length<1){ alert("No valid numbers found (0–36)."); return; }
  spins = arr;
  lastPrediction = null;
  refreshLive();
}
function appendBulkToLive(){
  const txt = document.getElementById("bulkBox").value;
  const arr = parseSpinsText(txt);
  if(arr.length<1){ alert("No valid numbers found (0–36)."); return; }
  spins = spins.concat(arr);
  lastPrediction = null;
  refreshLive();
}

/* =========================
   HISTORIC REPLAY HELPERS
========================= */
function replayStats(spinArr){
  const half = +document.getElementById("half").value;
  let bets=0,hits=0,streak=0,worst=0;

  for(let i=0;i<spinArr.length-1;i++){
    const hist = spinArr.slice(0, i+1);
    const chosen = chooseParamsForNext(hist);
    if(!chosen) continue;

    const centre = predictCentreFromModel(hist, chosen.model, chosen.shift);
    if(centre==null) continue;

    const covered = neighbours(centre, half);
    const result = spinArr[i+1];

    bets++;
    if(covered.includes(result)){
      hits++;
      streak=0;
    }else{
      streak++;
      worst = Math.max(worst, streak);
    }
  }

  const hitRate = bets ? (hits/bets)*100 : 0;
  return {spins: spinArr.length, bets, hits, hitRate, worst};
}

/* =========================
   EXCEL/CSV DAYS UPLOAD
========================= */
const daysFile = document.getElementById("daysFile");
const daysStatus = document.getElementById("daysStatus");
const daysResults = document.getElementById("daysResults");
const daysTbody = document.getElementById("daysTbody");
const totSpins = document.getElementById("totSpins");
const totBets = document.getElementById("totBets");
const totHit = document.getElementById("totHit");
const totWorst = document.getElementById("totWorst");

let loadedDays = []; // {name, spins[]}

function clearDays(){
  loadedDays = [];
  daysStatus.textContent = "";
  daysResults.style.display = "none";
  daysTbody.innerHTML = "";
}

async function loadDaysFile(){
  const file = daysFile.files && daysFile.files[0];
  if(!file){
    alert("Choose an Excel (.xlsx) or CSV file first.");
    return;
  }

  daysStatus.textContent = "Loading…";
  daysResults.style.display = "none";
  daysTbody.innerHTML = "";

  try{
    const name = file.name.toLowerCase();
    if(name.endsWith(".csv")){
      const text = await file.text();
      const matrix = parseCSVToMatrix(text);
      loadedDays = matrixToDays(matrix);
    }else{
      // XLSX/XLS
      const data = await file.arrayBuffer();
      const wb = XLSX.read(data, {type:"array"});
      const sheetName = wb.SheetNames[0];
      const ws = wb.Sheets[sheetName];
      const matrix = XLSX.utils.sheet_to_json(ws, {header:1, raw:true});
      loadedDays = matrixToDays(matrix);
    }

    loadedDays = loadedDays.filter(d=>d.spins.length>=2);

    if(loadedDays.length === 0){
      throw new Error("No valid day columns found. Make sure row 1 has day names, numbers below (0–36).");
    }

    renderDayResults();

    daysStatus.innerHTML =
      `<span class="pill good">LOADED</span> Loaded ${loadedDays.length} day columns. Click “Load to Live” for any day.`;

  }catch(e){
    console.error(e);
    daysStatus.innerHTML = `<span class="pill bad">ERROR</span> ${e.message || String(e)}`;
  }
}

function parseCSVToMatrix(text){
  // simple CSV split (works fine for your numeric layout)
  const rows = text.split(/\r?\n/).filter(r=>r.trim()!=="");
  return rows.map(r => r.split(","));
}

function matrixToDays(matrix){
  // matrix[0] = headers (days)
  if(!matrix || matrix.length < 2) return [];
  const headers = (matrix[0] || []).map(h => String(h ?? "").trim());
  const cols = Array.from({length: headers.length}, ()=>[]);

  for(let r=1;r<matrix.length;r++){
    const row = matrix[r] || [];
    for(let c=0;c<headers.length;c++){
      const cell = row[c];
      if(cell === null || cell === undefined || String(cell).trim()==="") continue;
      const v = parseInt(String(cell).trim(), 10);
      if(Number.isFinite(v) && v>=0 && v<=36){
        cols[c].push(v);
      }
    }
  }

  const days = [];
  for(let c=0;c<headers.length;c++){
    const dayName = headers[c] ? headers[c] : `Day ${c+1}`;
    days.push({name: dayName, spins: cols[c]});
  }
  return days;
}

function renderDayResults(){
  daysTbody.innerHTML = "";

  let totalSp=0, totalB=0, totalH=0;
  let overallWorst = 0;

  for(let i=0;i<loadedDays.length;i++){
    const d = loadedDays[i];
    const res = replayStats(d.spins);

    totalSp += res.spins;
    totalB += res.bets;
    totalH += res.hits;
    overallWorst = Math.max(overallWorst, res.worst);

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${escapeHtml(d.name)}</td>
      <td>${res.spins}</td>
      <td>${res.bets}</td>
      <td>${res.bets ? res.hitRate.toFixed(1)+"%" : "–"}</td>
      <td>${res.worst}</td>
      <td class="actions">
        <button class="btn2" type="button" onclick="loadDayToLive(${i})">Load to Live</button>
      </td>
    `;
    daysTbody.appendChild(tr);
  }

  totSpins.textContent = totalSp;
  totBets.textContent = totalB;
  totHit.textContent = totalB ? ((totalH/totalB)*100).toFixed(1)+"%" : "–";
  totWorst.textContent = overallWorst;

  daysResults.style.display = "block";
}

function loadDayToLive(idx){
  const d = loadedDays[idx];
  if(!d) return;
  spins = d.spins.slice();
  lastPrediction = null;
  refreshLive();
  window.scrollTo({top:0, behavior:"smooth"});
}

/* tiny helper */
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}

/* init */
window.addEventListener("load", ()=>{
  spinInput.focus();
  refreshLive();
});
</script>

</body>
</html>
