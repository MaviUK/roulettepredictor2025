<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Adaptive Roulette Predictor (Per-Spin Refit) + CSV + Martingale + Risk</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  *{box-sizing:border-box}
  body{margin:0;padding:1rem;background:#0b1020;color:#f5f5f5;font-family:system-ui}
  h1,h2{margin:.2rem 0 .6rem 0}
  .grid{display:grid;grid-template-columns:1.2fr 1fr;gap:1rem}
  @media(max-width:900px){.grid{grid-template-columns:1fr}}
  .card{background:#151a2c;border:1px solid rgba(255,255,255,.06);border-radius:14px;padding:1rem;box-shadow:0 14px 40px rgba(0,0,0,.35)}
  label{display:block;font-size:.9rem;opacity:.9;margin:.45rem 0 .25rem}
  input,textarea,select{width:100%;padding:.55rem .65rem;border-radius:10px;border:1px solid rgba(255,255,255,.15);background:#0b1020;color:#fff;outline:none}
  textarea{min-height:100px;resize:vertical}
  .row{display:flex;gap:.6rem;flex-wrap:wrap}
  .row > *{flex:1;min-width:180px}
  button{border:0;border-radius:999px;padding:.55rem .9rem;font-weight:650;cursor:pointer}
  .btn-primary{background:#ff3366;color:#fff}
  .btn-secondary{background:#232b49;color:#fff}
  button:disabled{opacity:.5;cursor:not-allowed}
  .small{font-size:.85rem;opacity:.8;line-height:1.35}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .pill{display:inline-flex;align-items:center;padding:.2rem .55rem;border-radius:999px;font-size:.75rem;font-weight:700;margin-right:.35rem}
  .good{background:rgba(0,200,140,.15);color:#4cf3b6}
  .bad{background:rgba(255,120,80,.15);color:#ffb899}
  .neutral{background:rgba(130,150,255,.15);color:#b3bfff}
  table{width:100%;border-collapse:collapse;margin-top:.6rem}
  th,td{border-bottom:1px solid rgba(255,255,255,.07);padding:.35rem .35rem;text-align:left;font-size:.85rem}
  th{opacity:.9}
  canvas{width:100%;height:220px;background:rgba(255,255,255,.03);border-radius:12px;border:1px solid rgba(255,255,255,.06)}
  .progress{height:10px;background:rgba(255,255,255,.10);border-radius:999px;overflow:hidden;margin-top:.4rem}
  .bar{height:100%;width:0%;background:#ff3366;transition:width .08s linear}
</style>
</head>
<body>

<h1>Adaptive Roulette Predictor (Refit per spin)</h1>
<p class="small">
Per-spin refit using last <b>N</b> directional distances for the upcoming direction.<br>
Objective: <b>reject</b> any candidate that creates worst streak &gt; cap inside the window → then <b>minimise</b> window worst streak → then <b>maximise</b> window hit%.
</p>

<div class="grid">

  <!-- LEFT: Live + Chart -->
  <div class="card">
    <h2>Live Mode</h2>

    <div class="row">
      <div>
        <label>Base stake / number</label>
        <input id="baseUnit" type="number" value="1" step="0.01" min="0.01">
      </div>
      <div>
        <label>Neighbour half-sector</label>
        <input id="halfSector" type="number" value="8" min="1" max="18">
        <div class="small">8 = 17 numbers covered</div>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Window N (per direction)</label>
        <input id="windowN" type="number" value="5" min="5" max="25">
        <div class="small">This is the directional “memory” used to refit after each spin.</div>
      </div>
      <div>
        <label>Streak cap (hard limit in optimisation window)</label>
        <input id="streakCap" type="number" value="10" min="1" max="50">
      </div>
    </div>

    <div class="row">
      <div>
        <label>Martingale reset after X consecutive losses</label>
        <input id="martReset" type="number" value="11" min="1" max="50">
        <div class="small">✅ Yes: stake resets to base after this many consecutive losing bets.</div>
      </div>
      <div>
        <label>Shift search range</label>
        <select id="shiftRange">
          <option value="0,1,2,3,4,5" selected>0–5</option>
          <option value="0,1,2,3,4,5,6,7,8,9,10">0–10</option>
        </select>
      </div>
    </div>

    <div class="row" style="align-items:end">
      <div>
        <label>Add spin (0–36)</label>
        <input id="spinInput" type="number" min="0" max="36" placeholder="e.g. 23">
        <div class="small">Tip: press <b>Enter</b> to add quickly.</div>
      </div>
      <div style="flex:0;min-width:360px">
        <button class="btn-primary" id="addSpinBtn" type="button" onclick="addSpin()">Add Spin</button>
        <button class="btn-secondary" type="button" onclick="resetLive()">Reset</button>
        <!-- NEW: export -->
        <button class="btn-secondary" type="button" onclick="exportLiveNumbers()">Export .txt</button>
      </div>
    </div>

    <div id="liveStatus" class="small" style="margin-top:.6rem"></div>

    <div style="margin-top:.8rem">
      <h2>Param Drift (per spin)</h2>
      <canvas id="chart"></canvas>
      <div class="small" id="chartNote"></div>
    </div>

    <div style="margin-top:.8rem">
      <h2>Per-Spin Log</h2>
      <div class="small">Shows params chosen for each prediction + whether it hit.</div>
      <table class="mono">
        <thead>
          <tr>
            <th>#</th><th>Dir</th><th>Pred</th><th>Result</th><th>Hit</th><th>shift</th><th>a</th><th>b</th><th>WinWorst</th><th>WinHit%</th><th>WinBets</th>
          </tr>
        </thead>
        <tbody id="spinLogBody"></tbody>
      </table>
    </div>
  </div>

  <!-- RIGHT: CSV replay -->
  <div class="card">
    <h2>CSV Day Replay (columns = days)</h2>
    <p class="small">
      Upload CSV: header row is day names; each column contains that day’s spins (0–36).
      Simulation uses the SAME per-spin refit logic as Live mode, and will not bet until enough spins exist.
    </p>

    <input type="file" id="csvInput" accept=".csv" />

    <div class="row" style="align-items:end">
      <button class="btn-primary" id="runCsvBtn" onclick="runCsv()">Run CSV Replay</button>
      <button class="btn-secondary" onclick="clearCsv()">Clear Results</button>
    </div>

    <div id="csvProgWrap" style="margin-top:.6rem;display:none">
      <div class="small" id="csvProgText">Working…</div>
      <div class="progress"><div class="bar" id="csvProgBar"></div></div>
    </div>

    <div id="csvResults" style="display:none;margin-top:.8rem">
      <h2>Day Results</h2>
      <table class="mono">
        <thead>
          <tr>
            <th>Day</th><th>Spins</th><th>Bets</th><th>Hit%</th><th>WorstStreak</th><th>P&L</th><th>MaxDD</th><th>WorstStakeStep</th><th>Notes</th>
          </tr>
        </thead>
        <tbody id="dayBody"></tbody>
        <tfoot>
          <tr>
            <td><b>TOTAL</b></td>
            <td id="tSpins"></td>
            <td id="tBets"></td>
            <td id="tHit"></td>
            <td id="tWorst"></td>
            <td id="tPnL"></td>
            <td id="tDD"></td>
            <td id="tStep"></td>
            <td></td>
          </tr>
        </tfoot>
      </table>

      <h2 style="margin-top:1rem">Risk Overlay</h2>
      <div class="small" id="riskBox"></div>

      <h2 style="margin-top:1rem">Per-day parameter summary</h2>
      <div class="small">Average chosen params (only for spins where a prediction was possible).</div>
      <table class="mono">
        <thead>
          <tr><th>Day</th><th>Avg shift</th><th>Mode shift</th><th>Avg a</th><th>Avg b</th><th>Predictions made</th></tr>
        </thead>
        <tbody id="dayParamBody"></tbody>
      </table>
    </div>
  </div>
</div>

<script>
/* =========================
   WHEEL + INDEX
========================= */
const WHEEL = [0,32,15,19,4,21,2,25,17,34,6,27,13,36,11,30,8,23,10,5,24,16,33,1,20,14,31,9,22,18,29,7,28,12,35,3,26];
const IDX = {}; WHEEL.forEach((n,i)=>IDX[n]=i);

/* =========================
   UI REFS
========================= */
const baseUnit = document.getElementById("baseUnit");
const halfSectorEl = document.getElementById("halfSector");
const windowN = document.getElementById("windowN");
const streakCapEl = document.getElementById("streakCap");
const martResetEl = document.getElementById("martReset");
const shiftRangeEl = document.getElementById("shiftRange");
const spinInput = document.getElementById("spinInput");
const liveStatus = document.getElementById("liveStatus");
const spinLogBody = document.getElementById("spinLogBody");

const chart = document.getElementById("chart");
const chartNote = document.getElementById("chartNote");
const ctx = chart.getContext("2d");

const csvInput = document.getElementById("csvInput");
const runCsvBtn = document.getElementById("runCsvBtn");
const csvResults = document.getElementById("csvResults");
const dayBody = document.getElementById("dayBody");
const dayParamBody = document.getElementById("dayParamBody");

const csvProgWrap = document.getElementById("csvProgWrap");
const csvProgText = document.getElementById("csvProgText");
const csvProgBar = document.getElementById("csvProgBar");

const tSpins = document.getElementById("tSpins");
const tBets = document.getElementById("tBets");
const tHit = document.getElementById("tHit");
const tWorst = document.getElementById("tWorst");
const tPnL = document.getElementById("tPnL");
const tDD = document.getElementById("tDD");
const tStep = document.getElementById("tStep");

const riskBox = document.getElementById("riskBox");

/* =========================
   NEW: Enter-to-add + keep focus
========================= */
function focusSpin(){ spinInput.focus(); }
spinInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();     // prevents form-style submit / beep on some browsers
    addSpin();
    focusSpin();
  }
});
window.addEventListener("load", () => focusSpin());

/* =========================
   NEW: export live numbers to .txt
========================= */
function exportLiveNumbers(){
  if(!spins.length){
    alert("No live spins to export yet.");
    return;
  }
  const text = spins.join("\n");
  const blob = new Blob([text], {type:"text/plain"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  const stamp = new Date().toISOString().slice(0,19).replace(/[:T]/g,"-");
  a.download = `roulette_live_spins_${stamp}.txt`;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  },0);
}

/* =========================
   HELPERS
========================= */
function directionForIndex(i){ return i%2===0 ? "CW" : "CCW"; }

function neighboursForCentre(centreNum, half){
  const idx = IDX[centreNum];
  if(idx==null) return [];
  const nums=[];
  for(let off=-half; off<=half; off++){
    nums.push(WHEEL[(idx+off+37)%37]);
  }
  return nums;
}

function buildDistances(arr){
  const out=[];
  for(let i=1;i<arr.length;i++){
    const a=IDX[arr[i-1]], b=IDX[arr[i]];
    if(a==null||b==null) continue;
    const dir = directionForIndex(i);
    const dist = dir==="CW" ? (b-a+37)%37 : (a-b+37)%37;
    out.push({dir, dist, spinIndex:i}); // spinIndex is the index of spin producing this distance
  }
  return out;
}

function parseShiftOptions(){
  return shiftRangeEl.value.split(",").map(x=>parseInt(x,10)).filter(Number.isFinite);
}

function clamp01(x){ return Math.max(0, Math.min(1, x)); }

/* =========================
   CS CENTRE (needs params)
========================= */
function csCentre(history, params){
  if(history.length < 4) return null;

  const dists = buildDistances(history);
  const upcomingDir = directionForIndex(history.length);
  const ds = dists.filter(x=>x.dir===upcomingDir).map(x=>x.dist);
  if(ds.length < 3) return null;

  const S1 = ds[ds.length-3], S2 = ds[ds.length-2], S3 = ds[ds.length-1];
  const beta = S3 - S2;
  const gamma = (S3 - S2) - (S2 - S1);

  let step = Math.round(S3 + params.a*beta + params.b*gamma);
  step = (step + params.shift) % 37;

  const lastIdx = IDX[history[history.length-1]];
  const centreIdx = upcomingDir==="CW"
    ? (lastIdx + step) % 37
    : (lastIdx - step + 74) % 37;

  return WHEEL[centreIdx];
}

/* =========================
   FIT a,b from last (N+3) directional distances
========================= */
function fitABFromDirectionalDistances(distVals){
  const m = distVals.length - 3;
  if(m < 1) return null;

  let s11=0, s12=0, s22=0, t1=0, t2=0;

  for(let i=0;i<m;i++){
    const S1 = distVals[i];
    const S2 = distVals[i+1];
    const S3 = distVals[i+2];
    const S4 = distVals[i+3];

    const beta = (S3 - S2);
    const gamma = (S3 - S2) - (S2 - S1);
    const y = (S4 - S3);

    const x1 = beta;
    const x2 = gamma;

    s11 += x1*x1;
    s12 += x1*x2;
    s22 += x2*x2;
    t1  += x1*y;
    t2  += x2*y;
  }

  const ridge = 1e-6;
  s11 += ridge; s22 += ridge;

  const det = s11*s22 - s12*s12;
  if(Math.abs(det) < 1e-9) return {a:0, b:0};

  const inv11 =  s22/det;
  const inv12 = -s12/det;
  const inv22 =  s11/det;

  let a = inv11*t1 + inv12*t2;
  let b = inv12*t1 + inv22*t2;

  a = clamp01(a);
  b = clamp01(b);

  return {a,b};
}

/* =========================
   PER-SPIN RECALC OF shift,a,b (NO DEFAULTS)
========================= */
function recalcParamsForNextSpin(history){
  const N = +windowN.value;
  const cap = +streakCapEl.value;

  const dists = buildDistances(history);
  const upcomingDir = directionForIndex(history.length);
  const usable = dists.filter(x=>x.dir===upcomingDir);

  if(usable.length < (N + 3)) return null;

  const shiftOptions = parseShiftOptions();

  const fitWindow = usable.slice(-(N+3));
  const distVals = fitWindow.map(x=>x.dist);
  const ab = fitABFromDirectionalDistances(distVals);
  if(!ab) return null;

  const evalRecords = fitWindow.slice(3);

  const half = +halfSectorEl.value;

  let best = null;

  for(const shift of shiftOptions){
    const params = {shift, a:ab.a, b:ab.b};

    let worst=0, streak=0, hits=0, bets=0;

    for(const rec of evalRecords){
      const s = rec.spinIndex;
      if(s+1 >= history.length) continue;

      const histSlice = history.slice(0, s+1);
      const centre = csCentre(histSlice, params);
      if(centre==null) continue;

      const covered = neighboursForCentre(centre, half);
      const result = history[s+1];

      bets++;
      const hit = covered.includes(result);

      if(hit){ hits++; streak=0; }
      else { streak++; worst = Math.max(worst, streak); }

      if(worst > cap) break;
    }

    if(bets === 0) continue;
    if(worst > cap) continue;

    const hitRate = hits / bets;

    if(!best ||
      worst < best.worst ||
      (worst === best.worst && hitRate > best.hitRate)
    ){
      best = {params, worst, hitRate, bets};
    }
  }

  return best;
}

/* =========================
   LIVE STATE
========================= */
let spins = [];
let chartSeries = [];
let lastPredInfo = null;

function addSpin(){
  const v = parseInt(spinInput.value,10);
  if(!Number.isFinite(v) || v<0 || v>36) return;
  spinInput.value="";

  // settle previous prediction
  if(lastPredInfo){
    lastPredInfo.result = v;
    lastPredInfo.hit = lastPredInfo.covered.includes(v);
    appendSpinLog(lastPredInfo);
    updateChart();
  }

  spins.push(v);

  const chosen = recalcParamsForNextSpin(spins);
  if(!chosen){
    const dists = buildDistances(spins);
    const upcomingDir = directionForIndex(spins.length);
    const usable = dists.filter(x=>x.dir===upcomingDir).length;
    const need = (+windowN.value + 3);
    liveStatus.innerHTML =
      `<span class="pill neutral">WAIT</span> Not enough ${upcomingDir} directional distances yet. `+
      `Have ${usable}, need ${need}. No betting until enough data.`;
    lastPredInfo = null;
    focusSpin();
    return;
  }

  const centre = csCentre(spins, chosen.params);
  if(centre==null){
    liveStatus.innerHTML = `<span class="pill neutral">WAIT</span> Model not ready yet (needs more structure).`;
    lastPredInfo = null;
    focusSpin();
    return;
  }

  const half = +halfSectorEl.value;
  const covered = neighboursForCentre(centre, half);

  lastPredInfo = {
    i: spins.length,
    dir: directionForIndex(spins.length),
    pred: centre,
    covered,
    params: chosen.params,
    windowWorst: chosen.worst,
    windowHit: chosen.hitRate,
    windowBets: chosen.bets
  };

  chartSeries.push({shift:chosen.params.shift, a:chosen.params.a, b:chosen.params.b});

  liveStatus.innerHTML =
    `<span class="pill good">BET</span> Next centre: <b>${centre}</b> — cover <b>${covered.length}</b> numbers<br>`+
    `<span class="mono">Recalc params</span>: shift=${chosen.params.shift}, a=${chosen.params.a.toFixed(2)}, b=${chosen.params.b.toFixed(2)} `+
    `• windowWorst=${chosen.worst} • windowHit=${(chosen.hitRate*100).toFixed(1)}% • windowBets=${chosen.bets}`;

  focusSpin();
}

function resetLive(){
  spins = [];
  chartSeries = [];
  lastPredInfo = null;
  spinLogBody.innerHTML = "";
  liveStatus.innerHTML = "";
  clearChart();
  chartNote.textContent = "";
  focusSpin();
}

function appendSpinLog(info){
  const hitStr = info.hit ? "YES" : "NO";
  const tr = document.createElement("tr");
  tr.innerHTML = `
    <td>${info.i}</td>
    <td>${info.dir}</td>
    <td>${info.pred}</td>
    <td>${info.result}</td>
    <td>${hitStr}</td>
    <td>${info.params.shift}</td>
    <td>${info.params.a.toFixed(2)}</td>
    <td>${info.params.b.toFixed(2)}</td>
    <td>${info.windowWorst ?? "–"}</td>
    <td>${info.windowHit!=null ? (info.windowHit*100).toFixed(1)+"%" : "–"}</td>
    <td>${info.windowBets ?? "–"}</td>
  `;
  spinLogBody.prepend(tr);
}

/* =========================
   CHART
========================= */
function resizeCanvas(){
  const rect = chart.getBoundingClientRect();
  chart.width = Math.floor(rect.width * devicePixelRatio);
  chart.height = Math.floor(rect.height * devicePixelRatio);
}
window.addEventListener("resize", ()=>{ resizeCanvas(); updateChart(); });
resizeCanvas();

function clearChart(){ ctx.clearRect(0,0,chart.width,chart.height); }

function drawSeries(series, key, minV, maxV){
  const w=chart.width, h=chart.height;
  const pad=20*devicePixelRatio;
  const n=series.length;
  if(n<2) return;
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const x = pad + (i/(n-1))*(w-2*pad);
    const v = series[i][key];
    const y = pad + (1-(v-minV)/(maxV-minV))*(h-2*pad);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
}

function updateChart(){
  resizeCanvas();
  clearChart();
  const n = chartSeries.length;
  if(n<2){
    chartNote.textContent = n===0 ? "No params yet." : "Need at least 2 param points to draw.";
    return;
  }
  chartNote.textContent = `Showing ${n} parameter selections (latest on the right).`;

  ctx.globalAlpha = 1;
  ctx.lineWidth = 2*devicePixelRatio;

  ctx.setLineDash([]);
  drawSeries(chartSeries, "shift", 0, Math.max(5, ...parseShiftOptions()));

  ctx.setLineDash([6*devicePixelRatio,4*devicePixelRatio]);
  drawSeries(chartSeries, "a", 0, 1);

  ctx.setLineDash([2*devicePixelRatio,6*devicePixelRatio]);
  drawSeries(chartSeries, "b", 0, 1);

  ctx.setLineDash([]);
}

/* =========================
   CSV PARSE
========================= */
function parseCsv(text){
  const lines = text.split(/\r?\n/).filter(l=>l.trim()!=="");
  return lines.map(l=>l.split(/,|\t/));
}
function loadCsvFile(){
  return new Promise((resolve,reject)=>{
    const file = csvInput.files && csvInput.files[0];
    if(!file) return reject(new Error("No CSV selected"));
    const r = new FileReader();
    r.onload = e=>{
      const rows = parseCsv(e.target.result);
      if(rows.length<2) return reject(new Error("CSV must have header + data rows"));
      const headers = rows[0].map(h=>h.trim()||"Day");
      const cols = Array.from({length:headers.length}, ()=>[]);
      for(let i=1;i<rows.length;i++){
        for(let c=0;c<headers.length;c++){
          const cell=(rows[i][c]||"").trim();
          if(!cell) continue;
          const v = parseInt(cell,10);
          if(Number.isFinite(v)&&v>=0&&v<=36) cols[c].push(v);
        }
      }
      resolve({headers, cols});
    };
    r.readAsText(file);
  });
}

/* =========================
   MARTINGALE + P&L SIM
========================= */
function simulateDay(spinsDay){
  const half = +halfSectorEl.value;
  const base = +baseUnit.value;
  const resetAfter = +martResetEl.value;

  let stakePerNumber = base;
  let lossCount = 0;

  let bets=0,hits=0;
  let streak=0,worst=0;

  let pnl=0;
  let peak=0;
  let maxDD=0;

  let worstStakeStep = 0;
  let currentStep = 0;

  let predCount=0;
  let sumShift=0,sumA=0,sumB=0;
  const shiftFreq = new Map();

  let history=[];
  let lastBet = null;

  for(let i=0;i<spinsDay.length;i++){
    const result = spinsDay[i];

    if(lastBet){
      bets++;
      const covered = lastBet.covered;
      const totalStake = stakePerNumber * covered.length;
      const hit = covered.includes(result);

      if(hit){
        hits++;
        streak=0;
        pnl += (stakePerNumber*36) - totalStake;

        stakePerNumber = base;
        lossCount=0;
        currentStep=0;
      }else{
        pnl -= totalStake;
        streak++;
        worst = Math.max(worst, streak);

        lossCount++;
        if(lossCount >= resetAfter){
          stakePerNumber = base;
          lossCount=0;
          currentStep=0;
        }else{
          stakePerNumber *= 2;
          currentStep++;
          worstStakeStep = Math.max(worstStakeStep, currentStep);
        }
      }

      peak = Math.max(peak, pnl);
      maxDD = Math.max(maxDD, peak - pnl);
    }

    history.push(result);

    const chosen = recalcParamsForNextSpin(history);
    if(!chosen){
      lastBet = null;
      continue;
    }

    const centre = csCentre(history, chosen.params);
    if(centre==null){
      lastBet = null;
      continue;
    }

    predCount++;
    sumShift += chosen.params.shift;
    sumA += chosen.params.a;
    sumB += chosen.params.b;
    shiftFreq.set(chosen.params.shift, (shiftFreq.get(chosen.params.shift)||0)+1);

    lastBet = {
      centre,
      covered: neighboursForCentre(centre, half),
      params: chosen.params
    };
  }

  const hitRate = bets ? (hits/bets)*100 : 0;

  let modeShift = null;
  let bestF = -1;
  for(const [k,v] of shiftFreq.entries()){
    if(v>bestF){bestF=v; modeShift=k;}
  }

  return {
    spins: spinsDay.length,
    bets, hits, hitRate,
    worstStreak: worst,
    pnl, maxDD,
    worstStakeStep,
    paramSummary: {
      avgShift: predCount ? (sumShift/predCount) : null,
      modeShift,
      avgA: predCount ? (sumA/predCount) : null,
      avgB: predCount ? (sumB/predCount) : null,
      predCount
    }
  };
}

/* =========================
   CSV RUN
========================= */
let csvRunning=false;

async function runCsv(){
  if(csvRunning) return;
  csvRunning=true;
  runCsvBtn.disabled=true;

  dayBody.innerHTML="";
  dayParamBody.innerHTML="";
  csvResults.style.display="none";
  csvProgWrap.style.display="block";
  csvProgText.textContent="Loading CSV…";
  csvProgBar.style.width="0%";

  try{
    const {headers, cols} = await loadCsvFile();
    const days = cols.map((spins,i)=>({name:headers[i]||`Day ${i+1}`, spins}))
                     .filter(d=>d.spins.length>=2);

    if(days.length===0) throw new Error("No valid day columns found (need at least 2 spins per day).");

    let totalSpins=0,totalBets=0,totalHits=0,totalPnL=0;
    let totalWorst=0,totalDD=0,totalStep=0;

    let overallWorstStreak=0;
    let overallWorstStakeStep=0;
    let overallMaxDD=0;
    let losingDays=0;

    for(let j=0;j<days.length;j++){
      const d = days[j];
      csvProgText.textContent = `Simulating ${j+1}/${days.length}: ${d.name}…`;
      csvProgBar.style.width = (((j+1)/days.length)*100).toFixed(1)+"%";

      const res = simulateDay(d.spins);

      totalSpins += res.spins;
      totalBets += res.bets;
      totalHits += res.hits;
      totalPnL += res.pnl;
      totalWorst = Math.max(totalWorst, res.worstStreak);
      totalDD = Math.max(totalDD, res.maxDD);
      totalStep = Math.max(totalStep, res.worstStakeStep);

      overallWorstStreak = Math.max(overallWorstStreak, res.worstStreak);
      overallWorstStakeStep = Math.max(overallWorstStakeStep, res.worstStakeStep);
      overallMaxDD = Math.max(overallMaxDD, res.maxDD);
      if(res.pnl < 0) losingDays++;

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${d.name}</td>
        <td>${res.spins}</td>
        <td>${res.bets}</td>
        <td>${res.bets?res.hitRate.toFixed(1)+"%":"–"}</td>
        <td>${res.worstStreak}</td>
        <td>${formatMoney(res.pnl)}</td>
        <td>${formatMoney(res.maxDD)}</td>
        <td>${res.worstStakeStep}</td>
        <td>${res.worstStreak > +streakCapEl.value ? '<span class="pill bad">CAP HIT</span>' : ''}</td>
      `;
      dayBody.appendChild(tr);

      const ps = res.paramSummary;
      const tr2 = document.createElement("tr");
      tr2.innerHTML = `
        <td>${d.name}</td>
        <td>${ps.avgShift==null ? "–" : ps.avgShift.toFixed(2)}</td>
        <td>${ps.modeShift==null ? "–" : ps.modeShift}</td>
        <td>${ps.avgA==null ? "–" : ps.avgA.toFixed(2)}</td>
        <td>${ps.avgB==null ? "–" : ps.avgB.toFixed(2)}</td>
        <td>${ps.predCount}</td>
      `;
      dayParamBody.appendChild(tr2);

      await new Promise(r=>setTimeout(r, 0));
    }

    tSpins.textContent = totalSpins;
    tBets.textContent = totalBets;
    tHit.textContent = totalBets ? ((totalHits/totalBets)*100).toFixed(1)+"%" : "–";
    tWorst.textContent = totalWorst;
    tPnL.textContent = formatMoney(totalPnL);
    tDD.textContent = formatMoney(totalDD);
    tStep.textContent = totalStep;

    const coveredCount = (+halfSectorEl.value)*2 + 1;
    const base = +baseUnit.value;
    const cap = +streakCapEl.value;

    function cumLossForL(L){
      let sum=0;
      for(let k=0;k<L;k++){
        sum += base * Math.pow(2,k) * coveredCount;
      }
      return sum;
    }

    const requiredToSurviveCap = cumLossForL(cap);

    riskBox.innerHTML =
      `<span class="pill neutral">Coverage</span> ${coveredCount} numbers per bet (halfSector=${+halfSectorEl.value})<br>`+
      `<span class="pill neutral">Worst streak seen</span> ${overallWorstStreak}<br>`+
      `<span class="pill neutral">Max drawdown</span> ${formatMoney(overallMaxDD)}<br>`+
      `<span class="pill neutral">Worst martingale step</span> ${overallWorstStakeStep} (0=base, 1=double, …)<br>`+
      `<span class="pill neutral">Reset after</span> ${+martResetEl.value} consecutive losses<br>`+
      `<span class="pill neutral">To survive streak cap (${cap})</span> approx bankroll >= <b>${formatMoney(requiredToSurviveCap)}</b> (simplified worst-case)<br>`+
      `<span class="pill neutral">Losing days</span> ${losingDays}`;

    csvProgWrap.style.display="none";
    csvResults.style.display="block";

  }catch(e){
    alert(e.message || String(e));
    csvProgWrap.style.display="none";
  }finally{
    csvRunning=false;
    runCsvBtn.disabled=false;
  }
}

function clearCsv(){
  csvResults.style.display="none";
  dayBody.innerHTML="";
  dayParamBody.innerHTML="";
  csvProgWrap.style.display="none";
  csvProgBar.style.width="0%";
}

function formatMoney(x){
  const s = x>=0 ? "+" : "";
  return s + x.toFixed(2);
}
</script>
</body>
</html>
